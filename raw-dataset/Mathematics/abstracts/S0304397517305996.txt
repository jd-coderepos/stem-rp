Modelling in biology becomes necessary when systems are complex. However, the more complex the systems are, the harder models become to read and write. The most common ways of writing models are by writing reactions on species (discrete objects), or by writing rate equations for the populations of such species. One problem with such approaches is that the number of species is often so large that the model cannot be realistically enumerated. Another problem is that the number of species and reactions often fixed by default, whereas new variations of species and reactions are constantly being improvised by evolution in the long-term and moment to moment by the changing chemical environments and compartments living organisms inhabit and create within. Here we develop a modelling language Chromar that provides an extension to the representation of reactions, in which objects, called agents, carry attributes with associated types — for example, Leaf agents all have a mass attribute. Dynamics are given by stochastic rules defined on groups of agents — for example all agents of a specific type — and so enumerating the dynamics of each agent is not necessary. This compact representation addresses the first problem. Having a more compact representation can also help make models a tool for knowledge representation and exchange instead of just simulation. Further, if we think of agents as the analogue of species in reactions, then creating a new agent of some type effectively creates a new species, thereby addressing the second problem. We then develop an extension of Chromar equipped with deterministically changing time-dependent values (fluents) and aggregate values computed from the state of the system (observables). Fluents are useful for describing the context of the system, which is rarely static; observables are useful in abstracting away details of system behaviour and providing a way to observe the system during simulation. Finally, we develop an embedding of Chromar (and its extensions) in the programming language Haskell and demonstrate its applicability via two examples. Embedding Chromar in a general purpose programming language such as Haskell eases some of the constraints of modelling languages while still maintaining the naturalness of a domain-specific language.